# 计算机图像学实验

> PB17061227 唐华楹
>
> 实验环境：
>
> Windows10 家庭中文版
>
> python 3.8.2
>
> opencv-python 4.2.0.34

## 实验内容

## 1. 图像的点处理

### 1.1 灰度的线性变换

#### 1.1.1 实验原理

​		灰度线性变换就是对图像的每个点的灰度用一个线性函数作变换。根据线性函数的斜率于截距的不同能达到不同的效果。

#### 1.1.2 实验实现

​		具体实现很简单，首先利用OpenCV读入图像的灰度矩阵，之后对矩阵中每个点的灰度值，根据给定的线性函数求得变换后的灰度值即可，核心代码如下：

```python
def linear_trans(pic,k,b): # 对pic图片做线性变换
    (n,m) = pic.shape
    pic1 = [[round(k*pic[i][j]+b) for j in range(m)]for i in range(n)] # 进行线性变换得到新的灰度图
    return pic1
```

​		完整的源代码在 lab1_1.py 中

#### 1.1.3 实验结果

当斜率k=0.05,截距b=120时，灰度的范围受到了压缩，可以看出右图中的灰度分辨率也明显下降了

<img src="E:\STUDY\Computer Graphics\lab2\1.jpg" alt="1" style="zoom:67%;" />

### 1.2 灰度拉伸

#### 1.2.1 实验原理

​		灰度拉伸也是一种灰度变换方法，其思想类似于线性变换，只是变换函数变为了分段线性函数。灰度拉伸的优点就是能够突出显示想要的某些灰度区间。

#### 1.2.2 实验实现

​		实现类似于线性变换，只要将变换函数变为分段线性函数即可：

```python
def stretch_trans(pic,x1,y1,x2,y2): # 对pic图片做线性变换
    (n,m) = pic.shape
    pic1 = [[0 for j in range(m)]for i in range(n)] # 初始化新的灰度图
    for i in range(n):
        for j in range(m):
            t = pic[i][j]
            if (t < x1):
                pic1[i][j] = y1 / x1 * t
            elif (t > x2):
                pic1[i][j] = (y2 - y1) / (x2 - x1) * (t - x1) + y1
            else:
                pic1[i][j] = (255 - y2) / (255 - y2) * (t - x2) + y2
    return pic1
```

​		完整的源代码在 lab1_2.py 中

#### 1.2.3 实验结果

<img src="E:\STUDY\Computer Graphics\lab2\2.jpg" alt="2" style="zoom:67%;" />

### 1.3 灰度直方图与直方图均衡

#### 1.3.1 实验原理

​		灰度直方图方法是将数字图像中的所有像素，按照灰度值的大小，统计其出现的频率，用直方图的方法表示出来。直方图均衡则是将图像的灰度直方图中所有的灰度出现的频率进行均衡化的一种图像增强手段。

#### 1.3.2 具体实现

 		灰度直方图的统计很简单，只要扫描一遍图像灰度矩阵，每读取一个像素点的灰度，就把对应灰度的出现次数+1，最后按统计的灰度出现次数显示直方图即可。

​		直方图均衡化则对每个点的灰度，计算比其灰度更小的点的所占比例a，再用a去乘以最大灰度值即可得到均衡化后的该点的灰度值。

​		完整的源代码在 lab1_3.py 中

#### 1.3.3 实验结果

下图中左侧的是原图及其直方图，直方图显示的灰度范围在50-200之间；右侧显示的是直方图均衡化后的图片及均衡后的灰度直方图。

<img src="E:\STUDY\Computer Graphics\lab2\3.jpg" alt="3" style="zoom:67%;" />

## 2.数字图像的平滑

### 2.1原理与实现

​		椒盐噪声是指噪点的灰度值不是可能的最大的灰度值就是最小的灰度值。在本次实验中，增加噪声的过程就是对3%的点，等概率随机变为最大灰度或者最小灰度。

​		对于有噪声的图像，我们可以采用均值滤波或者中值滤波的方式。均值滤波的方法就是对每个点，取周围一定范围中的点的灰度的平均值作为去噪的结果；中值滤波则似乎选择了中位数作为结果。本次实验采用的窗口大小为3*3，即选择以周围一周的8个点和自己的灰度值为输入进行滤波。

​		需要注意的是在边界上的点则需要特殊处理，因为可能窗口的范围有一部分在图像外。对边缘的点的滤波时，本次实验只使用在图像范围内且在窗口内的点的灰度值作为滤波输入。

### 2.2实验结果

![4](E:\STUDY\Computer Graphics\lab2\4.jpg)

上图中左上方的图片为原图，右上方的图片为增加了椒盐噪声后的图片。

左下方为均值滤波的结果，可以看出，均值滤波对椒盐噪声的处理有一定效果，图像整体的灰度相对处理前更加均匀了，但是因此也降低了清晰度。这是因为噪声点的灰度受到周围正常点的灰度的平均后，更加接近正常的灰度范围了，但是在噪点周围的正常点却也因为噪点的影响，灰度产生了一定的偏移使得图像变得模糊。

右下方为中值滤波的结果，可以看出中值滤波对椒盐噪声的处理效果明显好于均值滤波，基本能够达到还原原图的效果。中值滤波的一个优点就是中位数不受个别极大极小值的影响，因此对于椒盐噪声能很好地滤除。

## 3.图像的边缘检测

### 3.1实验原理

边缘检测的常用方法就是根据一定的方法，考察每个像素在邻域内的灰度变化情况。变化量大的常常就是图像中某个物体的边缘。

### 3.2 实验实现

边缘检测主要使用以下几种常见的算子：

#### 3.2.1 Robert 算子

这种算子的实现比较特殊，不能直接用矩阵统一表示，所以实现的时候作了特殊处理。它根据下面的式子进行计算：
$$
G[F(x,y)]\approx|F(x,y)-F(x+1,y+1)|+|F(x+1,y)-F(x,y+1)|
$$
需要注意的是用OpenCV直接读取的灰度矩阵的数据类型是0-255的整数，直接减会可能导致溢出，所以实现的时候要先强制转换成int类型。

#### 3.2.2 其他算子

​		其他三种算子都可以用矩阵形式来表示，计算时把该点周围9宫格内的点分别乘以矩阵对应位置的系数并求和即可。

* Sobel算子的模板如下：
  $$
  \begin{equation}      
  \left(
    \begin{array}{ccc} 
      -1 & -2 & -1\\ 
      0 & 0 & 0\\
      1 & 2 & 1
    \end{array}
  \right)
  or
  \left(
    \begin{array}{ccc} 
      -1 & 0 & 1\\ 
      -2 & 0 & 2\\
      -1 & 0 & 1
    \end{array}
  \right)
  \end{equation}
  $$
  分别用来检测行或者列方向的边缘

* Prewitt算子的模板如下：
  $$
  \begin{equation}      
  \left(
    \begin{array}{ccc} 
      -1 & -1 & -1\\ 
      0 & 0 & 0\\
      1 & 1 & 1
    \end{array}
  \right)
  or
  \left(
    \begin{array}{ccc} 
      -1 & 0 & 1\\ 
      -1 & 0 & 1\\
      -1 & 0 & 1
    \end{array}
  \right)
  \end{equation}
  $$
  使用方法完全与Sobel算子相同

* Laplace算子则是近似计算的二阶导数的大小，它的模板如下：
  $$
  \begin{equation}      
  \left(
    \begin{array}{ccc} 
      0 & 1 & 0\\ 
      1 & -4 & 1\\
      0 & 1 & 0
    \end{array}
  \right)
  or
  \left(
    \begin{array}{ccc} 
      -1 & -1 & -1\\ 
      -1 & 8 & -1\\
      -1 & -1 & -1
    \end{array}
  \right)
  \end{equation}
  $$
  对于变换后的结果，还需要作尺度变换变回0-255范围内以便显示

### 3.3实验结果

对blood1.bmp的检测结果：

![5](E:\STUDY\Computer Graphics\lab2\5.jpg)

对map.bmp的检测结果：

![6](E:\STUDY\Computer Graphics\lab2\6.jpg)

## 4.数字图像的Fourier变换

### 4.1 实验原理

离散傅里叶变换可以将离散的信号序列在不同频率上的分量显示出来，从而允许我们在频谱上根据频率对图像作进一步的处理。而快速傅里叶变换则对离散傅里叶变换进行了优化，使得时间复杂度从$O(N^2)$降低到了$O(NlogN)$。

对于二维的情况，只要执行两次傅里叶变换，一次对每行，一次对每列即可。

### 4.2 实验实现

本次实验实现的是递归版的FFT，对图像作变换时，对行和列分别作FFT。对于频谱的幅度，使用$f(x)=log(x)+1$ 进行了变换。

### 4.3实验结果

对Rect1.bmp的变换结果如下图所示：

右上方位频谱的幅度变换后的结果，左下方为对频谱的幅值作逆变换的结果，右下方为对频谱的相位作逆变换的结果。

![7](E:\STUDY\Computer Graphics\lab2\7.jpg)

对Rect2.bmp的变换结果：

![8](E:\STUDY\Computer Graphics\lab2\8.jpg)





## 备注

实验的代码在python环境下运行，需要安装OpenCV、matplotlib、numpy包，可以在命令行中执行pip install命令安装。

在对应的环境中，代码可以通过如下命令执行：

```
python lab*.py path/name.bmp
```

lab*.py是要执行的代码，path/name.bmp是要读取的图片的路径。